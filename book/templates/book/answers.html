{% extends 'book/base.html' %}
{% block content %}
<section class="banner-area relative">
    <div class="container">
        <div class="row d-flex align-items-center justify-content-center">
            <div class="about-content col-lg-12">
                <h1 class="text-white">
                    {{title}}.
                </h1>
                <div class="link-nav">
						<span class="box">
							<a href="{% url 'home' %}">Головна сторінка</a>
							<i class="lnr lnr-arrow-right"></i>
							<a href="{% url 'answers' %}">{{title}}</a>
						</span>
                </div>
            </div>
        </div>
    </div>
    <div class="rocket-img">
        <img src="img/rocket.png" alt="">
    </div>
</section>
<!-- End Banner Area -->
<!-- Start Sample Area -->
<section class="sample-text-area">
    <div class="container">
        <hr>
        <h4 class="sample-text">Відповіді на вправи.</h4>
        <hr>
        <p class="sample-text"><h4><b>Глава 1</b></h4></p>
        <p class="sample-text"><b>1.1. </b>Є відсортований список з 128 імен, і ви шукаєте в ньому значення методом
            бінарного
            пошуку. Яка максимальна
            кількість перевірок для цього може знадобитись?</p>
        <p class="sample-text"><i>Відповідь:</i>7</p>
        <p class="sample-text"><b> 1.2.</b>Припустимо, розмір списку збільшився вдвічі. Як зміниться максимальна
            кількість
            перевірок?</p>
        <p class="sample-text"><i>Відповідь:</i>8</p>
        <p class="sample-text"><b>1.3. </b>Відоме прізвище, необхідно знайти номер в телефонній книзі.</p>
        <p class="sample-text"><i>Відповідь: </i>O(log n)</p>
        <p class="sample-text"><b>1.4. </b>Відомий номер, необхідно знайти прізвище в телефонній книзі. (Підказка: вам
            буде
            необхідно провести пошук по
            всій книзі!)</p>
        <p class="sample-text"><i>Відповідь:</i>O(n)</p>
        <p class="sample-text"><b>1.5. </b>Необхідно прочитати телефони всіх людей в телефонній книзі.</p>
        <p class="sample-text"><i>Відповідь: </i>O(n)</p>
        <p class="sample-text"><b>1.6. </b> Необхідно прочитати телефони всіх людей, прізвища яких починаються з літери
            «А».
            (Підступне питання! В ньому
            залучені концепції, які більш детально розглядаються в главі 4. Прочитайте відповідь – скоріш за все, вона
            вас
            здивує).</p>
        <p class="sample-text"><i>Відповідь: </i>O(n). Можливо, хтось подумає: «Я роблю це тільки для однієї з 26 літер,
            а
            значить, час виконання повинен
            дорівнювати О(n/26)». Запам'ятайте просте правило: в «О-велике» ігноруються числа, що залучені в операціях
            додавання,
            віднімання, множення чи ділення. Жодне з наступних значень не є вірним записом «О-велике»: О(n + 26), О(n -
            26), О(n
            * 26), О(n / 26). Всі вони еквівалентні O(n)! Чому? Якщо вам цікаво, знайдіть розділ “Знов про «О-велике» в
            главі 4
            і прочитайте про константи в цьому записі (константа – це просто число; в цьому питанні 26 є константою).
        </p>
        <p class="sample-text"><h4><b>Глава 2</b></h4></p>
        <p class="sample-text"><b>2.1. </b>Припустимо, ви будуєте додаток для керування фінансами.</p>
        <img src="/media/Answers/Answers - 1.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text">Щоденно ви записуєте всі свої витрати. В кінці місяця ви аналізуєте витрати і
            розраховуєте
            скільки коштів було
            витрачено. При роботі з даними виконується багато операцій вставки і відносно небагато операцій читання. Яку
            структуру використати – масив чи список?</p>
        <p class="sample-text"><i>Відповідь: </i>В цьому випадку витрати додаються в список щоденно, а читання всіх
            даних
            відбувається раз на місяць. Для
            масивів характерно швидке читання і повільна вставка. Оскільки вставка буде виконуватись набагато частіше, ніж
            читання, є сенс скористуватись зв’язаним списком. Крім того, читання в зв’язаних списках відбувається
            повільно лише
            якщо звертатись до випадкових елементів списку. В нашому випадку читатись будуть всі елементи списку, тому
            зв’язаний
            список добре впорається з читанням. Отже, зв’язаний список стане хорошим розв'язком цієї задачі.</p>
        <p class="sample-text"><b>2.2. </b>Припустимо, ви пишете додаток для приймання замовлень від відвідувачів
            ресторану.
            Додаток повинен зберігати
            список замовлень. Офіціанти додають замовлення в список, а кухарі читають замовлення зі списку і виконують
            їх.
            Замовлення утворюють чергу: офіціанти додають замовлення в кінець черги, а кухар бере перше замовлення з
            черги і
            починає готувати.</p>
        <img src="/media/Answers/Answers - 2.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text">Яку структуру даних ви б використали для реалізації цієї черги: масив чи зв’язаний
            список?
            (Підказка: зв’язані
            списки добре підходять для вставки/видалення, а масиви – для довільного доступу до елементів. Що з цього
            знадобиться
            в цьому випадку?)</p>
        <p class="sample-text"><i>Відповідь: </i>Зв’язаний писок. Вставка відбувається дуже часто (офіціанти додають
            замовлення), а зв’язані списки
            ефективно виконують цю операцію. Ні пошук, ні довільний доступ (сильні сторони масивів) вам не знадобляться,
            тому що
            кухар завжди вилучає з черги перше замовлення.</p>
        <p class="sample-text"><b>2.3. </b> Проведемо уявний експеримент. Припустимо, Facebook зберігає список імен
            користувачів. Коли хтось намагається
            зайти на сайт Facebook, система намагається знайти ім’я користувача. Якщо ім’я входить в список імен
            зареєстрованих
            користувачів, вхід дозволяється. Користувачі приходять на Facebook достатньо часто, тому пошук по списку
            буде
            виконуватись часто. Будемо вважати, що Facebook використовує бінарний пошук для пошуку в списку. Бінарному
            пошуку
            необхідний довільний доступ – алгоритм повинен миттєво звернутись до середнього елементу поточної чистини
            списку.
            Знаючи цю обставину, як би ви реалізували список користувачів: у вигляді масиву чи у вигляді зв’язаного
            списку?</p>
        <p class="sample-text"><i>Відповідь: </i>У вигляді відсортованого масиву. Масиви забезпечують довільний доступ –
            ви
            можете миттєво отримати
            елемент з середини масиву. Зі зв’язаними списками це неможливо. Щоб отримати елемент з середини зв’язаного
            списку,
            вам знадобиться почати з першого елемента і переходити за посиланнями до потрібного елементу.</p>
        <p class="sample-text"><b>2.4. </b>Користувачі також досить часто створюють нові облікові записи на Facebook.
            Припустимо, ви вирішили використати
            масив для зберігання списку користувачів. Які недоліки має масив у виконанні вставки? Припустимо, ви
            використовуєте
            бінарний пошук для пошуку облікових даних. Що станеться під час додавання нових користувачів в масив</p>
        <p class="sample-text"><i>Відповідь: </i>Вставка в масив виконується повільно. Крім того, якщо ви використовуєте
            бінарний пошук для знаходження
            імен користувачів, масив необхідно відсортувати. Припустимо, користувач з ім’ям Adit В реєструється на
            Facebook.
            Його ім’я буде вставлено в кінець масиву. Отже, масив необхідно буде відсортувати під час кожної вставки
            імені.</p>
        <p class="sample-text"><b>2.5. </b>Насправді Facebook не використовує ні масив, ні зв’язаний список для
            зберігання
            інформації про користувачів.
            Розглянемо гібридну структуру даних: масив зв’язаних списків. Є масив з 26 елементів. Кожен елемент містить
            посилання на зв’язаний список. Наприклад, перший елемент масиву вказує на зв’язаний список всіх імен
            користувачів,
            які починаються на літеру «А». Другий елемент вказує на зв’язаний список всіх імен користувачів, що
            починаються на
            літеру «В» і т.д.</p>
        <img src="/media/Answers/Answers - 3.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text">Припустимо, користувач з іменем «Adit B» реєструється на Facebook і ви бажаєте додати
            його в
            список. Ви звертаєтесь
            до елементу 1 масиву, знаходите зв’язаний список елементу 1 і додаєте «Adit B» в кінець списку. Тепер
            припустимо, що
            зареєструвати необхідно користувача «Zakhir H». Ви звертаєтесь до елементу 26, який містить зв’язаний список
            всіх
            імен, які починаються з «Z» і перевіряєте чи наявний «Zakhir H» в цьому списку.</p>
        <p class="sample-text">Тепер порівняйте цю гібридну структуру даних з масивами і зв’язаними списками. Чи буде
            вона
            швидша, чи повільніша за
            кожну вихідну структуру під час пошуку чи вставки? Приводити «О-велике» не потрібно, просто оберіть одне з
            двох:
            швидше чи повільніше.</p>
        <p class="sample-text"><i>Відповідь: </i>Пошук – повільніше, ніж для масивів, і швидше, ніж для зв’язаних
            списків.
            Вставка – швидше, ніж для
            масивів, і з такою ж швидкістю для зв’язаних списків. Отже, гібридна структура поступається масиву у
            швидкості
            пошуку, але не гірше зв’язаних списків для всього іншого. Далі в книзі буде розглянута інша гібридна
            структура
            даних, що називається хеш-таблицею. Вона дасть деяке уявлення про те, як будувати складні структури даних з
            більш
            простих.</p>
        <p class="sample-text">Що ж в дійсності використовує сервіс Facebook? Ймовірно, десяток різних баз даних, за
            якими
            стоять різні структури
            даних: хеш-таблиці, в-дерева і т.д. Масиви і зв’язані списки стають структурними елементами для побудови
            більш
            складних структур даних.</p>
        <p class="sample-text"><h4><b>Глава 3</b></h4></p>
        <p class="sample-text"><b>3.1. </b>Припустимо, є стек викликів наступного вигляду:</p>
        <img src="/media/Answers/Answers - 4.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text">Що можна сказати про поточний стан програми на основі цього стеку викликів?</p>
        <p class="sample-text"><i>Відповідь: </i>Деякі спостереження, про які ви могли б згадати:</p>
        <p class="sample-text"><i class="fa-solid fa-cube" style="font-size: 1rem"></i> спочатку викликається функція
            greet для
            змінної name = maggie;</p>
        <p class="sample-text"><i class="fa-solid fa-cube" style="font-size: 1rem"></i> після функція greet викликає
            функцію
            greet2 для змінної name = maggie;</p>
        <p class="sample-text"><i class="fa-solid fa-cube" style="font-size: 1rem"></i> на цій стадії функція greet
            знаходиться
            в незавершеному, призупиненому стані;</p>
        <p class="sample-text"><i class="fa-solid fa-cube" style="font-size: 1rem"></i> поточним викликом функції є
            виклик
            greet2;</p>
        <p class="sample-text"><i class="fa-solid fa-cube" style="font-size: 1rem"></i> після завершення цього виклику
            функція
            greet продовжить виконання.</p>
        <p class="sample-text"><b>3.2. </b>Припустимо, ви випадково написали рекурсивну функцію, яка нескінченно
            викликає сама
            себе. Як ви вже бачили,
            комп’ютер виділяє пам’ять в стеку під час кожного виклику функції. А що станеться зі стеком у випадку
            нескінченного
            виконанні рекурсії?</p>
        <p class="sample-text"><i>Відповідь: </i>Стек буде зростати нескінченно. Кожній програмі виділяється обмежений
            об’єм
            пам’яті в стеку. Коли весь
            простір буде вичерпано (а це рано чи пізно станеться), програма завершиться з помилкою переповнення стека.
        </p>
        <p class="sample-text"><b>4.1. </b>Напишіть код для функції sum (див.вище).</p>
        <p class="sample-text"><i>Відповідь: </i></p>
        <p class="jetbrains sample-text">
            def sum(list): <br>
            &nbsp if list == [ ]: <br>
            &nbsp &nbsp return 0 <br>
            &nbsp return list[0] + sum(list[1: ])
        </p>
        <p class="sample-text"><b>4.2. </b>Напишіть рекурсивну функцію для підрахунку елементів в списку.</p>
        <p class="sample-text"><i>Відповідь: </i></p>
        <p class="jetbrains sample-text">
            def count(list): <br>
            &nbsp if list == [ ] : <br>
            &nbsp &nbsp return 0 <br>
            &nbsp return 1 + count(list[1: ])
        </p>
        <p class="sample-text"><b>4.3. </b>Знайдіть найбільше число в списку.</p>
        <p class="sample-text"><i>Відповідь: </i></p>
        <p class="jetbrains sample-text">
            def max(list): <br>
            &nbsp if len(list) == 2: <br>
            &nbsp &nbsp return list[0] if list[0] > list[1] else list[1] <br>
            &nbsp sub_max = max(list[1: ]) <br>
            &nbsp return list[0] if list[0] > sub_max else sub_max <br>
        </p>
        <p class="sample-text"><b>4.4. </b>Пам’ятаєте бінарний пошук з глави 1? Він також належить до класу
            алгоритмів
            «розділяй і володарюй». Чи
            зможете ви визначити базовий і рекурсивний випадок для бінарного пошуку?</p>
        <p class="sample-text"><i>Відповідь: </i>Базовим випадком для бінарного пошуку є масив, який містить всього один
            елемент. Якщо шуканий елемент
            збігається з елементом масиву – ви знайшли його! У зворотному випадку елемент в масиві відсутній.</p>
        <p class="sample-text">В рекурсивному випадку для бінарного пошуку масив ділиться навпіл, одна половина
            відкидається, а
            для іншої
            проводиться бінарний пошук.</p>
        <p class="sample-text">Запишіть «О-велике» для кожної з наступних операцій:</p>
        <p class="sample-text"><b>4.5. </b>Вивід значення кожного елементу масиву.</p>
        <p class="sample-text"><i>Відповідь: </i>O(n).</p>
        <p class="sample-text"><b>4.6. </b>Подвоєння значення кожного елементу масиву.</p>
        <p class="sample-text"><i>Відповідь: </i>O(n).</p>
        <p class="sample-text"><b>4.7. </b>Подвоєння тільки першого елементу масиву.</p>
        <p class="sample-text"><i>Відповідь: </i>O(n).</p>
        <p class="sample-text"><b>4.8. </b>Створення таблиці множення для всіх елементів масиву. Наприклад, якщо масив
            складається з елементів [2. 3, 7,
            8, 10], спочатку кожен елемент помножується на 2, потім на 3, потім на 7 і т.д.</p>
        <p class="sample-text"><i>Відповідь: </i>O(n<sup>2</sup>).</p>
        <p class="sample-text"><h4><b>Глава 5</b></h4></p>
        <p class="sample-text">Які з наступних функцій є послідовними?</p>
        <p class="sample-text"><b>5.1.</b><i>Відповідь: </i>функція послідовна.</p>
        <p class="sample-text"><b>5.2. </b><i>Відповідь: </i>функція непослідовна.</p>
        <p class="sample-text"><b>5.3. </b><i>Відповідь: </i>функція непослідовна.</p>
        <p class="sample-text"><b>5.4. </b><i>Відповідь: </i>функція послідовна.</p>
        <p class="sample-text">Припустимо, є чотири хеш-функції, які отримують рядки:</p>
        <p class="sample-text">1. Перша функція повертає «1» для будь-якого вхідного значення.</p>
        <p class="sample-text">2. Друга функція повертає довжину рядка в якості індексу.</p>
        <p class="sample-text">3. Третя функція повертає перший символ рядка в якості індексу. Таким чином, всі рядки,
            що
            починаються з «а»,
            хешуються в одну позицію, всі рядки, що починаються з «b» - в іншу і т.д.</p>
        <p class="sample-text">4. Четверта функція ставить у відповідність кожній літері просте число: a = 2, b = 3, c =
            5, d =
            7, e = 11 і т.д.
            Для рядку хеш-функцією стає залишок від ділення суми всіх значень на розмір хешу. Наприклад, якщо розмір
            кешу
            дорівнює 10, то для рядка «bag» буде розраховано індекс 3 + 2 + 17 % 10 = 22 % 10 = 2.</p>
        <p class="sample-text">В якому з цих прикладів хеш-функції будуть забезпечувати хороший розподіл? Вважайте, що
            хеш-таблиця містить 10
            елементів.</p>
        <p class="sample-text"><b>5.5. </b>Телефонна книга, в якій ключами є імена, а значеннями – номери телефонів.
            Задано
            наступний список імен: Esther,
            Ben, Bob, Dan.</p>
        <p class="sample-text"><i>Відповідь: </i>Хеш-функції C та D забезпечують хороший розподіл.</p>
        <p class="sample-text"><b>5.6. </b>Зв’язок розміру батарейки з напругою. Розміри батарейок: А, АА, ААА, АААА.
        </p>
        <p class="sample-text"><i>Відповідь: </i>Хеш-функції B і D забезпечують хороший розподіл.</p>
        <p class="sample-text"><b>5.7. </b>Зв’язок назв книг з іменами авторів. Назви книг: «Maus», «Fun Home»,
            «Watchmen».</p>
        <p class="sample-text"><i>Відповідь: </i>Хеш-функції B, С і D забезпечують хороший розподіл.</p>
        <p class="sample-text"><h4><b>Глава 6</b></h4></p>
        <p class="sample-text">Застосуйте алгоритм пошуку в ширину до кожного з цих графів, щоб знайти рішення.</p>
        <p class="sample-text"><b>6.1. </b>Знайдіть довжину найкоротшого шляху від початкового вузла до кінцевого.</p>
        <img src="/media/Answers/Answers - 5.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><i>Відповідь: </i>Довжина найкоротшого шляху дорівнює 2.</p>
        <p class="sample-text"><b>6.2. </b>Знайдіть довжину найкоротшого шляху від «cab» до «bat».</p>
        <img src="/media/Answers/Answers - 6.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><i>Відповідь: </i>Довжина найкоротшого шляху дорівнює 2.</p>
        <p class="sample-text"><b>6.3. </b>Перед вами невеликий граф мого вранішнього розпорядку.</p>
        <img src="/media/Answers/Answers - 7.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text">Для кожного з наступних трьох списків вкажіть, чи дійсний він, чи недійсний.</p>
        <img src="/media/Answers/Answers - 8.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><i>Відповідь: </i>А – недійсний; B – дійсний, C – недійсний.</p>
        <p class="sample-text"><b>6.4. </b>Трохи збільшимо вихідний граф. Побудуйте дійсний список для цього графу.</p>
        <img src="/media/Answers/Answers - 9.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><i>Відповідь: </i>1 – Прокинутись, 2 – Зробити зарядку, 3 – Прийняти душ, 4 – Почистити
            зуби, 5 –
            Одягнутись, 6 – Спакувати
            обід, 7 – Поснідати.</p>
        <p class="sample-text"><b>6.5. </b>Які з наступних графів також є деревами?</p>
        <img src="/media/Answers/Answers - 10.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><i>Відповідь: </i>А – дерево, В – не дерево, С – дерево. В останньому прикладі дерево
            просто
            повернуто вбік. Дерева
            складають підкатегорію графів, тому будь-яке дерево є графом, але граф не обов’язково є деревом.</p>
        <p class="sample-text"><h4><b>Глава 7</b></h4></p>
        <p class="sample-text"><b>7.1. </b>Яка вага найкоротшого шляху від початку до кінця в кожному з наступних
            графів?</p>
        <img src="/media/Answers/Answers - 11.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><i>Відповідь: </i>А – 8; B – 60; С – підступне питання (найкоротший шлях не існує через
            наявність
            циклу з від’ємною вагою).</p>
        <p class="sample-text"><h4><b>Глава 8</b></h4></p>
        <p class="sample-text"><b>8.1. </b>Ви працюєте в фірмі з виробництва меблів та постачаєте їх по всій країні.
            Коробки з
            меблями розміщуються у
            вантажівці. Всі коробки мають різний розмір, і ви намагаєтесь заповнити вільний простір вантажівки
            максимально
            ефективно. Яким чином підібрати коробки, що б завантаження мало максимальну ефективність? Запропонуйте
            жадібну
            стратегію. Чи буде отримане рішення оптимальним?</p>
        <p class="sample-text"><i>Відповідь: </i>Жадібна стратегія полягає в тому, щоб обрати найбільшу коробку, що
            вміщується у
            вільному просторі, що
            залишився, і повторювати це до тих пір, поки ще можна обрати хоча б одну коробку. Ні, таке рішення не буде
            оптимальним.</p>
        <p class="sample-text"><b>8.2. </b>Ви прямуєте до Європи, і у вас є сім днів на знайомство з видатними місцями.
            Ви
            присвоюєте кожному місцю
            вартість в балах (наскільки ви хочете його побачити) і робите оцінку тривалості подорожі. Як забезпечити
            максимальну
            вартість (побачити все найважливіше) під час поїздки? Запропонуйте жадібну стратегію. Чи буде отримане
            рішення
            оптимальним?</p>
        <p class="sample-text"><i>Відповідь: </i>Обирайте пам’ятку з найбільшою вартістю в балах, яку ви встигнете
            відвідати за
            час, що залишився.
            Зупиніться, коли таких пам’яток не залишиться. Ні, таке рішення не буде оптимальним.</p>
        <p class="sample-text"><b>8.3. </b>Швидке сортування.</p>
        <p class="sample-text"><i>Відповідь: </i>Ні.</p>
        <p class="sample-text"><b>8.4. </b>Пошук в ширину.</p>
        <p class="sample-text"><i>Відповідь: </i>Так.</p>
        <p class="sample-text"><b>8.5. </b>Алгоритм Дейкстри.</p>
        <p class="sample-text"><i>Відповідь: </i>Так.</p>
        <p class="sample-text"><b>8.6. </b>Листоноша повинен доставити листи у 20 будинків. Йому необхідно знайти
            найкоротший
            шлях, який проходить через
            усі 20 будинків. Чи є ця задача NP-повною?</p>
        <p class="sample-text"><i>Відповідь: </i>Так.</p>
        <p class="sample-text"><b>8.7. </b>Є задача з пошуку максимальної кліки в множині людей (клікою називається
            множина
            людей, кожна з яких знайома з
            усіма іншими). Чи є ця задача NP-повною</p>
        <p class="sample-text"><i>Відповідь: </i>Так.</p>
        <p class="sample-text"><b>8.8. </b>Ви малюєте карту США, на якій два сусідніх штати не можуть бути розфарбовані
            в
            однаковий колір. Необхідно знайти
            мінімальну кількість кольорів, при яких будь-які два сусідні штати будуть розфарбовані в різні кольори. Чи є
            ця
            задача NP-повною?</p>
        <p class="sample-text"><i>Відповідь: </i>Так.</p>
        <p class="sample-text"><h4><b>Глава 9</b></h4></p>
        <p class="sample-text"><b>9.1. </b>Припустимо, до предметів додався ще один: МР3-плеєр. Його вага 1 фунт і
            коштує він
            $1000. Чи варто його брати?</p>
        <p class="sample-text"><i>Відповідь: </i>Так. Ви зможете покласти в рюкзак МР3-плеєр, iPhone і гітару, загальною
            вартістю $4500.</p>
        <p class="sample-text"><b>9.2.</b> <i>Відповідь: </i>Візьміть воду, їжу і камеру.</p>
        <p class="sample-text"><b>9.3. </b>Намалюйте та наповніть таблицю для розрахунку найдовшого спільного підрядка
            між
            рядками blue та clues.</p>
        <p class="sample-text"><i>Відповідь: </i></p>
        <img src="/media/Answers/Answers - 12.png" class="img-fluid rounded mx-auto d-block" alt="">
        <p class="sample-text"><h4><b>Глава 10</b></h4></p>
        <p class="sample-text"><b>10.1. </b>В прикладі з Netflix схожість між вдома користувачами оцінювалася за
            формулою відстані. Але не всі користувачі
            оцінюють фільми однаково. Припустимо, є два користувачі, Йогі і Пінкі, смаки яких співпадають. Але Йогі
            ставить 5
            балів будь-якому фільму, який йому сподобався, А Пінкі більш прискіплива і ставить «п’ятірки» тільки
            найкращим
            фільмам. Наче смаки однакові, але за метрикою відстані вони не є сусідами. Як врахувати різність в
            стратегіях
            оцінювання?</p>
        <p class="sample-text"><i>Відповідь: </i>Можна скористатись нормалізацією: ви розраховуєте середню оцінку для
            кожної людини і використовуєте її
            для масштабування оцінок. Наприклад, ви визначили, що середня оцінка Пінкі дорівнює 3, а середня оцінка Йогі
            – 3,5.
            Відповідно оцінки Пінкі трохи збільшуються так, щоб її середня оцінка теж дорівнювала 3,5. Після цього
            оцінки можна
            порівнювати за однією шкалою.</p>
        <p class="sample-text"><b>10.2. </b>Припустимо, Netflix визначає групу «авторитетів». Скажемо, Квентін Тарантіно
            і Уес Андресон належать до
            числа авторитетів Netflix, тому їх оцінки сильніше впливають, ніж оцінки звичайних користувачів. Як змінити
            систему
            рекомендацій, щоб вона враховувала підвищену цінність оцінок авторитетів?</p>
        <p class="sample-text"><i>Відповідь: </i>При застосуванні алгоритму k найближчих сусідів можна збільшити вагу
            оцінок авторитетів. Припустимо, у
            вас троє сусідів: Джо, Дейв і Уес Андресон (авторитет). Вони поставили фільму «Гольф-клуб» оцінки 3,4 і 5
            відповідно. Замість того щоб розраховувати середнє арифметичне їх оцінок (3 + 4 + 5 / 3 = 4 зірки), ви
            просто
            підвищуєте вагу оцінки Уеса Андерсона: 3 + 4 + 5 + 5 + 5 + / 5 = 4,4 зірки.</p>
        <p class="sample-text"><b>10.3. </b>У сервісу Netflix мільйони користувачів. В наведеному раніше прикладі
            рекомендаційна система будувалась для
            п’яти найближчих сусідів. П’ять – це замало? Чи забагато?</p>
        <p class="sample-text"><i>Відповідь: </i>Замало. Якщо обмежитись малою кількістю сусідів, існує висока
            ймовірність того, що результати будуть
            викривлені. Існує хороше емпіричне правило: для N користувачів слід розглядати sqrt(N) сусідів.</p>
        <hr></hr>
    </div>
</section>
{% endblock %}